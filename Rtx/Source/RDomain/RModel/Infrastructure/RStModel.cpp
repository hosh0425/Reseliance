#include "RStModel.h"

#include "RParameter.h"
#include "RResponse.h"
#include "RMainWindow.h"
#include "RGLWidgetEngine.h"
#include "RGLWidget.h"

#include "SLUSolver.h"
#include "STransformationMatrixAssembler.h"
#include "SNode.h"
#include "STrussElement.h"
#include "SFrameElement.h"
#include "SQuad4Element.h"
#include "SGenericSection.h"
#include "SMaterial.h"
#include "SLUSolver.h"
#include "SAssembler.h"

RStModel::RStModel(QObject *parent, QString name)
: RModel(parent, name)
{
	QString domainNameStr = objectName() + "Domain";
	theStModelDomain = new RDomain(0, domainNameStr);

	theGLWidget = 0;
	theGLWidgetEngine = 0;
}

RStModel::~RStModel()
{
	if (theStModelDomain) {
		delete theStModelDomain;
	}
	theStModelDomain = 0;
}

QString RStModel::getStInputFile() const
{
	return theStInputFile;
}

void RStModel::setStInputFile(QString value)
{
	theStInputFile = RDomain::stringToFilePath(value);

	// Delete all children
	QObjectList oldChildrenList = theStModelDomain->findChildren<QObject *>();
	for (int i = 0; i < oldChildrenList.count(); i++) {
		delete oldChildrenList[i];
	}

	// Open the input file
	RMainWindow *mainWindow = qobject_cast<RMainWindow *>(parent()->parent());
	QObjectList childrenList;
	QString errorMessage;
	int result = theDomain->openFile(theStInputFile, &childrenList, &errorMessage, true);
	if (childrenList.count() == 0 || result < 0) {
		rCritical() << "Error: The file" << theStInputFile << "passed to the model" << objectName() << "is either empty or cotains error. Please correct the file and try again.";
	}

	theAllParametersList.clear();
	theStructuralObjects.clear();
	theResponses.clear();
	// Removing old responses
	while (theResponseList.count() > 0) {
		//theResponseList[0]->setModel(0);
		delete theResponseList.takeAt(0);
	}
	// Update the domain tree
	if (mainWindow) {
		mainWindow->updateTree("Domain");
	}

	for (int i = 0; i < childrenList.count(); i++) {
		RParameter *parameter = qobject_cast<RParameter *>(childrenList[i]);

		if (parameter) {
			// If the childrenList[i] is an RParameter, add it to theAllParametersList
			theAllParametersList << parameter;
		} else {

			// Re-parent the childrenList: The parent is set as theStModelDomain
			childrenList[i]->setParent(theStModelDomain);

			// Set the childrenList to be autoGenerated so that they don't appear in the saved file
			RObject *rObject = qobject_cast<RObject *>(childrenList[i]);
			rObject->setAutoGenerated(true);
		}
	}
}

QString RStModel::getResponses() const
{
	QString result;
	for (int i = 0; i < theStructuralObjects.count(); i++) {
		QString structuralObjectName = theStructuralObjects[i].data()->objectName();
		QString propertyName = theResponses[i];

		result += structuralObjectName + '.' + propertyName + "; ";
	}	
	//result += ";";
	return result;
}

void RStModel::setResponses(QString value)
{
	QList<RPointer<RObject> > tempStructuralObjects;
	QStringList tempResponses;

	QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
	QStringList stringList = value.split(regExp, QString::SkipEmptyParts);
	for (int i = 0; i < stringList.count(); i++) {
		QStringList nameProperty = stringList[i].split('.',  QString::SkipEmptyParts);
		if (nameProperty.count() != 2) {
			//Error
			rCritical() << "Error in the Model" << objectName() << ": Invalid response.";
			return;
		}
		QString structuralObjectName = nameProperty[0].trimmed();
		RObject *structuralObject = theStModelDomain->findChild<RObject *>(structuralObjectName);
		if (!structuralObject) {
			rCritical() << "Error in the Model" << objectName() << ": Could not find a structural object named" << structuralObjectName << "in the structural domain.";
			return;
		}
		tempStructuralObjects << structuralObject;

		// Error handling here: if this structural object has such a property
		const QMetaObject *metaObject = structuralObject->metaObject();
		QString propertyStr = nameProperty[1].trimmed();
		QByteArray byteArrayName = propertyStr.toLatin1();
		const char * propertyCharStar = byteArrayName.data();
		int propertyIndex = metaObject->indexOfProperty(propertyCharStar);
		if (propertyIndex < 0) {
			rCritical() << "Error in the Model" << objectName() << ": Could not find the property named" << propertyStr << "in the structural object" << structuralObjectName << ".";
			return;
		}

		tempResponses << propertyStr;
	}

	// Removing the old responses
	theStructuralObjects.clear();
	theResponses.clear();
	theStructuralObjects = tempStructuralObjects;
	theResponses = tempResponses;

	while (theResponseList.count() > 0) {
		//theResponseList[0]->setModel(0);
		delete theResponseList.takeAt(0);
	}

	// Instantiating the response objects one for each structure
	for (int i = 0; i < theStructuralObjects.count(); i++) {
		theDomain->createObject(objectName() + theStructuralObjects[i].data()->objectName() + theResponses[i], "RGenericResponse");
		RResponse *response = qobject_cast<RResponse *>(theDomain->getLastAddedObject());
		response->setModel(this);
		theResponseList << response;
	}

	// Update the domain tree
	RMainWindow *mainWindow = qobject_cast<RMainWindow *>(parent()->parent());
	if (mainWindow) {
		mainWindow->updateTree("Domain");
	}
}

QList<RParameter *> RStModel::getAllParametersList(bool *ok)
{
	*ok = true;
	return theAllParametersList;
}

int RStModel::evaluateModel(bool evaluateDDM, RObject::RParameterType parameterType, int threadID)
{	
	SAssembler *theAssembler = theStModelDomain->findChild<SAssembler *>();
	if (!theAssembler) {
		rCritical() << "Error: In the model" << objectName() << ": The St input file does not include any assembler.";
		return -1;
	}

	SSOESolver *theSolver = theStModelDomain->findChild<SSOESolver *>();
	if (!theSolver) {
		rCritical() << "Error: In the model" << objectName() << ": The St input file does not include any solver.";
		return -1;
	}

	// Setting the domain in assmbler
	theAssembler->setDomain(theStModelDomain);

	RObject::ROutputDisplayLevelType assemblerDisplayLevel = theAssembler->getOutputDisplayLevel();
	RObject::ROutputDisplayLevelType solverDisplayLevel = theSolver->getOutputDisplayLevel();
	if (!getDisplayOutput()) {
		theAssembler->setOutputDisplayLevel(RObject::None);
		theSolver->setOutputDisplayLevel(RObject::None);
	}
	
	
	

	/////////////////////////////////////////////////////////////////////////
	// PASTE THE CORE IMPLEMENTATION OF SLinearStaticDialog::analyze BELOW //
	/////////////////////////////////////////////////////////////////////////



	// Establish the stiffness matrix
	gsl_matrix *K = theAssembler->getStiffnessMatrix();

	// Establish the load vector
	gsl_vector *F = theAssembler->getLoadVector();

	// Get number of free degrees of freedom
	int numDOFs = F->size;

	// Allocate memory for the solution vector
	gsl_vector *u = gsl_vector_calloc(numDOFs);

	// Solve the system of equations
	theSolver->solveSOE(K, F, u);

	// Set the new displacements in theStructuralModel
	theAssembler->setDisplacements(u);

	// Free vectors and matrices
	gsl_vector_free(u);



	////////////////////////////////////////////////////////////////////
	// END OF THE IMPLEMENTATION OF SLinearStaticDialog::analyze      //
	////////////////////////////////////////////////////////////////////







	if (getDisplayOutput()) {
		// Do the plot (Please have thePlot and theCurve as data members).
		// rDebug() <<
	}

	// Updating responses
	for (int i = 0; i < theResponseList.count(); i++) {
		QByteArray byteArrayName = theResponses[i].toLatin1();
		const char * propertyName = byteArrayName.data();

		bool ok;
		double response = theStructuralObjects[i].data()->property(propertyName).toDouble(&ok);
		if (!ok) {
			rCritical() << "Error: In the model" << objectName() << ": Could not read the property" << theResponses[i] << "in nthe structural object" << theStructuralObjects[i].data()->objectName() << ".";
			return -1;
		}

		theResponseList[i]->setCurrentValue(response);
	}

	theAssembler->setOutputDisplayLevel(assemblerDisplayLevel);
	theSolver->setOutputDisplayLevel(solverDisplayLevel);

	return 0;
}

QStringList RStModel::getActionList()
{
	QStringList actionList;
	actionList << "&Display";
	return actionList;
}

void RStModel::display()
{
	RMainWindow *mainWindow = qobject_cast<RMainWindow *>(parent()->parent());
	if (!theGLWidget) {
		theGLWidget = new RGLWidget(mainWindow);
		mainWindow->addSubWindow(theGLWidget, QString("3D Display of %1").arg(objectName()), false);
		theGLWidgetEngine = theGLWidget->getEngine();
	}

	theGLWidgetEngine->clearAll();


	QList<SElement *> elementList = theStModelDomain->findChildren<SElement *>();

	for (int i = 0; i < elementList.count(); i++) {

		SFrameElement *frameElement = qobject_cast<SFrameElement *>(elementList[i]);
		if (frameElement) {
			SNode *node1 = qobject_cast<SNode *>(frameElement->getNode1());
			SNode *node2 = qobject_cast<SNode *>(frameElement->getNode2());

			double x1 = node1->getXCoordinateValue();
			double y1 = node1->getYCoordinateValue();
			double z1 = node1->getZCoordinateValue();
			double x2 = node2->getXCoordinateValue();
			double y2 = node2->getYCoordinateValue();
			double z2 = node2->getZCoordinateValue();

			theGLWidgetEngine->addLine(x1, y1, z1, x2, y2, z2, Qt::black);

			//if (displayElementNamesAction->isChecked()) {
			//	theGLWidgetEngine->addText( 0.5*(x1+x2),  0.5*(y1+y2),  0.5*(z1+z2), elementList[i]->objectName(), Qt::blue);
			//}

			continue;
		}

		STrussElement *trussElement = qobject_cast<STrussElement *>(elementList[i]);
		if (trussElement) {
			SNode *node1 = qobject_cast<SNode *>(trussElement->getNode1());
			SNode *node2 = qobject_cast<SNode *>(trussElement->getNode2());

			double x1 = node1->getXCoordinateValue();
			double y1 = node1->getYCoordinateValue();
			double z1 = node1->getZCoordinateValue();
			double x2 = node2->getXCoordinateValue();
			double y2 = node2->getYCoordinateValue();
			double z2 = node2->getZCoordinateValue();

			theGLWidgetEngine->addLine(x1, y1, z1, x2, y2, z2, Qt::black);

			//if (displayElementNamesAction->isChecked()) {
			//	theGLWidgetEngine->addText( 0.5*(x1+x2),  0.5*(y1+y2),  0.5*(z1+z2), elementList[i]->objectName(), Qt::blue);
			//}
			continue;

		}

		SQuad4Element *quad4Element = qobject_cast<SQuad4Element *>(elementList[i]);
		if (quad4Element) {
			SNode *node1 = qobject_cast<SNode *>(quad4Element->getNode1());
			SNode *node2 = qobject_cast<SNode *>(quad4Element->getNode2());
			SNode *node3 = qobject_cast<SNode *>(quad4Element->getNode3());
			SNode *node4 = qobject_cast<SNode *>(quad4Element->getNode4());

			double x1 = node1->getXCoordinateValue();
			double y1 = node1->getYCoordinateValue();
			double z1 = node1->getZCoordinateValue();
			double x2 = node2->getXCoordinateValue();
			double y2 = node2->getYCoordinateValue();
			double z2 = node2->getZCoordinateValue();
			double x3 = node3->getXCoordinateValue();
			double y3 = node3->getYCoordinateValue();
			double z3 = node3->getZCoordinateValue();
			double x4 = node4->getXCoordinateValue();
			double y4 = node4->getYCoordinateValue();
			double z4 = node4->getZCoordinateValue();

			theGLWidgetEngine->addSurface(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, Qt::gray, Qt::black);

			//if (displayElementNamesAction->isChecked()) {
			//	theGLWidgetEngine->addText( 0.25*(x1+x2+x3+x4),  0.25*(y1+y2+y3+y4),  0.25*(z1+z2+z3+z4), elementList[i]->objectName(), Qt::blue);
			//}

			continue;
		}
	}


	// Plot node numbers
	//if (displayNodeNamesAction->isChecked()) {
		QList<SNode *> nodeList = theStModelDomain->findChildren<SNode *>();
		for (int i = 0; i < nodeList.count(); i++) {
			SNode *theNode = qobject_cast<SNode *>(nodeList[i]);
			theGLWidgetEngine->addText(theNode->getXCoordinateValue(), theNode->getYCoordinateValue(), theNode->getZCoordinateValue(), theNode->objectName(), Qt::red);
		}
	//}

	theGLWidgetEngine->update3D();

	// Draw the axes
	double characteristicDimension = theGLWidgetEngine->getCharacteristicDimension();
	theGLWidgetEngine->addLine(0.0, 0.0, 0.0, 1.5*characteristicDimension, 0.0, 0.0, Qt::gray);
	theGLWidgetEngine->addLine(0.0, 0.0, 0.0, 0.0, 1.5*characteristicDimension, 0.0, Qt::gray);
	theGLWidgetEngine->addLine(0.0, 0.0, 0.0, 0.0, 0.0, 1.5*characteristicDimension, Qt::gray);
	theGLWidgetEngine->addText(1.52*characteristicDimension, 0.0, 0.0, QString("x"), Qt::gray);
	theGLWidgetEngine->addText(0.0, 1.52*characteristicDimension, 0.0, QString("y"), Qt::gray);
	theGLWidgetEngine->addText(0.0, 0.0, 1.52*characteristicDimension, QString("z"), Qt::gray);

	theGLWidgetEngine->update3D();
}

bool RStModel::canBeRunParallelly() { 
	return false;
}