#include "RModel.h"

#include <QApplication>
#include <QMetaProperty>
#include <QTimer>

#include "RParameter.h"
#include "RRandomVariable.h"
#include "RDecisionVariable.h"
#include "RConstant.h"
#include "RResponse.h"

#include "RLocation.h"
#include "RLocationResponse.h"
#include "RFunction.h"

#include <gsl/gsl_math.h>
#include <gsl/gsl_linalg.h>

#include <qreadwritelock.h>
#include <QMutex>
#include <QMutexLocker>


RModel::RModel(QObject *parent, QString name)
	: RObject(parent, name)
{
	theDomain = qobject_cast<RDomain *>(parent);
	theDisplayOutput = false;

	theDisplayOutputLock = new QReadWriteLock();
	theAllParameterListLock = new QMutex();


}

RModel::~RModel()
{
	delete theDisplayOutputLock;
	delete theAllParameterListLock;

}

void RModel::setObjectName(const QString &name)
{
	QString oldName = objectName();
	QObject *object = qobject_cast<QObject *>(this);
	object->setObjectName(name);

	// Renaming auto-generated responses
	QList<RResponse *> responseList = findChildren<RResponse *>();
	for (int i = 0; i < responseList.count(); i++) {
		if (responseList[i]->isAutoGenerated()) {
			QString responseName = responseList[i]->objectName();
			if (responseName.contains(oldName)) {
				QString newResponseName = responseName.replace(oldName, name);
				responseList[i]->setObjectName(newResponseName);
			}
		}
	}
}

bool RModel::getDisplayOutput()
{

	bool value;

	theDisplayOutputLock->lockForRead();
	value = theDisplayOutput;
	theDisplayOutputLock->unlock();

	return value;
}

void RModel::setDisplayOutput(bool value)
{
	theDisplayOutputLock->lockForWrite();
	theDisplayOutput = value;
	theDisplayOutputLock->unlock();
}

bool RModel::contains(RParameter *value)
{
	// start of safe area scope
	{
		QMutexLocker locker(theAllParameterListLock);
		if (theAllParametersList.isEmpty()) {
			bool ok;
			getAllParametersList(&ok);
		}
	}
	// end of safe area scope

	// we are not sure that the hash has been filled (because some children may have reimplemented the method of getAllParametersList)
	// so if the hash is empty, fill it with all parameters list
	if (theAllParametersHash.isEmpty()){

		for (int i = 0; i < theAllParametersList.count(); ++i) {
			theAllParametersHash.insert(theAllParametersList[i], true);
		}
	}

	bool containsFlag = theAllParametersHash.contains(value);

	if (!containsFlag) {
		// Also check if the input RConstants that carry responses from downstream models depend on the passed RParameter (value)
		QList<RConstant *> contList = getConstantList();
		for (int i = 0; i < contList.count(); i++) {
			QList<RParameter *> upstreamParameterList = contList[i]->getUpstreamParameterList();
			if (upstreamParameterList.isEmpty()) {
				continue;
			} else {
				if (upstreamParameterList.contains(value)) {
					containsFlag = true;
					return true;
				}
			}
		}
	}

	return containsFlag;
}

int RModel::setResponsesThatFlowUpstream(int threadID)
{
	return 0;
}

int RModel::runAnalysis(bool evaluateDDM, RObject::RParameterType parameterType, int threadID)
{
	// Checking properties is done in RFunction::populateLists()
	//// Checking if all pointer properties are filled out
	//int status = checkProperties();
	//if (status < 0) {
	//	return -1;
	//}
	
	int result = 0;
	QList<RResponse *> inputResponseList = getResponseList();
	for (int i = 0; i < inputResponseList.count(); i++) {
		if (inputResponseList[i]->parent() == this) {
			rCritical(threadID) << "Error in model" << this->objectName() << ": The response" << inputResponseList[i]->objectName() << "is both input and output to this model. Such a loop cannot exist.";
			return -1;
		}
		
		if (!inputResponseList[i]->isAnalyzed(threadID)) {
			RModel *theModel = qobject_cast<RModel *>(inputResponseList[i]->getModel());
			if (!theModel) {
				rCritical(threadID) << "Error: Response" << inputResponseList[i]->objectName() << "is not associated with any model.";
				return -1;
			}

			result = theModel->runAnalysis(evaluateDDM, parameterType, threadID);

			if (result < 0) {
				rCritical(threadID) << "Error: Could not run the analysis in the model" << theModel->objectName() << ".";
				return result;
			}
		}
	}

	if (evaluateDDM) {
		theDDMMap.clear();
	}

	result = evaluateModel(evaluateDDM, parameterType, threadID);

	if (result < 0) {
		if (result > -9) {
			rCritical(threadID) << "Error: Could not evaluate the model" << objectName() << ".";
		}
		if (result == -10) {
			rCritical(threadID) << "Error: Could not evaluate the DDM in model" << objectName() << ".";
		}
		return result;
	}

	// DDM
	if (evaluateDDM) {

		// start of safe area scope
		{
			QMutexLocker locker(theAllParameterListLock);

			if (theAllParametersList.isEmpty()) {
				bool ok;
				getAllParametersList(&ok);
			
				if (!ok) {
					rCritical(threadID) << "Error: Could not get the parameter list of the model" << objectName() << ".";
					return -1;
				}
			}
		}
		// end of safe area

		if (result == 0) {
			// If the return value of evaluateModel is 1, it mean that the model has the DDM implementation
			// If the return value of evaluateModel is 0, it mean that the model does NOT have the DDM implementation and finite difference should be perfoemed
			result = evaluateModelGradient(parameterType);
			if (result < 0) {
				rCritical(threadID) << "Error: Could not evaluate the gradient of the model" << objectName() << ".";
				return -1;
			}
		}

		// Establish theDependenceMap once and for all; that is, this will be run only at first evaluation of the model
		if (theDependenceMap.isEmpty()) { //????? Is this a good condition?
			// Iterate on the inputResponseList
			for (int i = 0; i < inputResponseList.count(); i++) {
				QMap<RParameter *, double> theGradientMap = inputResponseList[i]->getGradientMap();
				QList<RParameter *> dependenceToThisResponseList = theGradientMap.uniqueKeys();//????

				// Find the index of this input response in theAllParametersList
				int index = theAllParametersList.indexOf(inputResponseList[i]);

				// Iterate on the RParameters that affect this input response, namely dependenceToThisResponseList, and add the index of this response to the map of that parameter
				for (int j = 0; j < dependenceToThisResponseList.count(); j++) {
					theDependenceMap.insertMulti(dependenceToThisResponseList[j], index);
				}
			}

			// Iterate on the list of direct input parameters depending on which type are being differentiated for (DV/RV/C)
			QList<RParameter *> inputParameterList;
			if (parameterType == RObject::RandomVariable) {
				QList<RRandomVariable *> tempParameterList = getRandomVariableList();
				for (int i = 0; i < tempParameterList.count(); i++) {
					inputParameterList << tempParameterList[i];
				}
			} else if (parameterType == RObject::DecisionVariable) {
				QList<RDecisionVariable *> tempParameterList = getDecisionVariableList();
				for (int i = 0; i < tempParameterList.count(); i++) {
					inputParameterList << tempParameterList[i];
				}
			} else if (parameterType == RObject::RandomVariable) {
				QList<RConstant *> tempParameterList = getConstantList();
				for (int i = 0; i < tempParameterList.count(); i++) {
					inputParameterList << tempParameterList[i];
				}
			}
			
			// Add the -1 to the map of direct input parameters to indicate they are direct input
			for (int i = 0; i < inputParameterList.count(); i++) {
				theDependenceMap.insertMulti(inputParameterList[i], -1);
			}
		}


		// Get a list of output responses in order to begin evaluation of their gradient
		QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();

		// Export a list of RV/DV/C that affect this model from theDependenceMap
		QList<RParameter *> dependenceParameterList = theDependenceMap.uniqueKeys();

		// Iterate on the outputResponseList
		for (int i = 0; i < outputResponseList.count(); i++) {
			RResponse *outputResponse = outputResponseList[i];

			// Declaring theGradientMap for this outputResponse
			QMap<RParameter *, double> theGradientMap;

			// Extract the map of DDM for this response from theDDMMap (This is basically the gradient of this response to model inputs, calculated in the sub-class)
			// Note: A QList of these gradients are exported, since the outputResponse can be an RLocationResponse with 3 gradients
			QList<QMap<RParameter *, double> > outputResponseDDMMapList = theDDMMap.values(outputResponse);

			// Iterate on the outputResponseDDMMapList to get each of the gradient vectors (maps) of thsi response (E.g., if this is an RLocationResponse, it has 3 gradients (maps))
			for (int j = 0; j < outputResponseDDMMapList.count(); j++) {
				QMap<RParameter *, double> outputResponseDDMMap = outputResponseDDMMapList[j];
			
				// Iterate on the list of parameters that this response should be differentiated with respect to, namely dependenceParameterList
				for (int k = 0; k < dependenceParameterList.count(); k++) {
					RParameter *dependenceParameter = dependenceParameterList[k];

					// Exporting the index list of input responses that depend on this dependenceParameter (RV/DV/C)
					QList<int> indexList = theDependenceMap.values(dependenceParameter);						

					// Declare the double that stored the d(outputResponse) / d(dependenceParameter)
					double diff = 0.0;

					for (int l = 0; l < indexList.count(); l++) {
						int index = indexList[l];
						if (index == -1) {
							// Means that the model directly depends to the dependenceParameter
							diff += outputResponseDDMMap.value(dependenceParameter, 0.0);
						} else {
							// Get the pointer to the input response with the index "index" in theAllParametersList
							RResponse *inputResponse = qobject_cast<RResponse *>(theAllParametersList[index]);
							if (!inputResponse) {
								rCritical(threadID) << "Error: Could not evaluate the gradient of the model" << objectName() << ". The parameter" << theAllParametersList[index]->objectName() << "in not a response.";
								return -1;
							}

							// Export the gradient elements of the inputResponse with respect to the dependenceParameter (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
							QMap<RParameter *, double> inputResponseGradientMap = inputResponse->getGradientMap();
							QList<double> inputResponseGradientdoubleList = inputResponseGradientMap.values(dependenceParameter);
							
							// Export the DDM elements of the outputResponse with respect to the inputResponse (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
							QList<double> DDMdoubleList = outputResponseDDMMap.values(inputResponse);

							int inputResponseGradientdoubleCount = inputResponseGradientdoubleList.count();
							if (DDMdoubleList.count() != inputResponseGradientdoubleCount) {
								rCritical(threadID) << "Error: Could not evaluate the gradient of the model" << objectName() << " due to inconsistency between the nummber of DDMs of the output response" << outputResponse->objectName() << "with respect to input response" << inputResponse->objectName() << "and the number of derivatives of" << inputResponse->objectName() << "with respect to" << dependenceParameter->objectName() << ".";
								return -1;
							}

							// Add up the product of these 2 double lists:  d(outputResponse) / d(dependenceParameter) = [d(outputResponse) / d(inputResponse)] * [d(inputResponse) / d(dependenceParameter)]
							for (int m = 0; m < inputResponseGradientdoubleCount; m++) {
								// "inputResponseGradientdoubleCount - 1 - m" is used in the following formula because the order of saving, e.g., lat, lng, and alt in an RLocationResponse, in theGradientMap has been reversed. That's because the most recently written variable is retrived first using QMap::values(...).
								diff += DDMdoubleList[m] * inputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m];
							}
						}
					}
					// Assign this element of theGradientMap
					theGradientMap.insertMulti(dependenceParameter, diff);
				}
			}
			// Submit theGradientMap to the outputResponse
			outputResponse->setGradientMap(theGradientMap);
		}		
	}

	return 0;
}

QList<RRandomVariable *> RModel::getRandomVariableList()
{
	QList<RRandomVariable *> randomVariableList;
	
	// start of safe area scope
	{
		QMutexLocker locker(theAllParameterListLock);
		if (theAllParametersList.isEmpty()) {
			bool ok;
			getAllParametersList(&ok);
		}
	}
	// end of safe area scope

	QList<RParameter *> parameterList = theAllParametersList;
	for (int i = 0; i < parameterList.count(); i++) {
		RRandomVariable *randomVariable = qobject_cast<RRandomVariable *>(parameterList[i]);			
		if (randomVariable) {
			randomVariableList.append(randomVariable);
		}
	}
	return randomVariableList;
}

QList<RDecisionVariable *> RModel::getDecisionVariableList()
{
	QList<RDecisionVariable *> decisionVariableList;
	
	// start of safe area scope
	{
		QMutexLocker locker(theAllParameterListLock);
		if (theAllParametersList.isEmpty()) {
			bool ok;
			getAllParametersList(&ok);
		}
	}
	// end of safe area scope

	QList<RParameter *> parameterList = theAllParametersList;
	for (int i = 0; i < parameterList.count(); i++) {
		RDecisionVariable *decisionVariable = qobject_cast<RDecisionVariable *>(parameterList[i]);			
		if (decisionVariable) {
			decisionVariableList.append(decisionVariable);
		}
	}
	return decisionVariableList;
}

QList<RConstant *> RModel::getConstantList()
{
	QList<RConstant *> constantList;
	
	// start of safe area scope
	{
		QMutexLocker locker(theAllParameterListLock);
		if (theAllParametersList.isEmpty()) {
			bool ok;
			getAllParametersList(&ok);
		}
	}
	// end of safe area scope

	QList<RParameter *> parameterList = theAllParametersList;
	for (int i = 0; i < parameterList.count(); i++) {
		RConstant *constant = qobject_cast<RConstant *>(parameterList[i]);			
		if (constant) {
			constantList.append(constant);
		}
	}
	return constantList;
}

QList<RResponse *> RModel::getResponseList()
{
	QList<RResponse *> responseList;
	
	// start of safe area scope
	{
		QMutexLocker locker(theAllParameterListLock);
		if (theAllParametersList.isEmpty()) {
			bool ok;
			getAllParametersList(&ok);
		}
	}
	// end of safe area scope

	QList<RParameter *> parameterList = theAllParametersList;
	for (int i = 0; i < parameterList.count(); i++) {
		RResponse *response = qobject_cast<RResponse *>(parameterList[i]);			
		if (response) {
			responseList.append(response);
		}
	}
	return responseList;
}

void RModel::setResponseAnalyzed(bool analyzed, int threadID)
{
	QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();
	for (int i = 0; i < outputResponseList.count(); i++) {
		outputResponseList[i]->setAnalyzed(analyzed, threadID);
	}
}

QList<RParameter *> RModel::getAllParametersList(bool *ok)
{
	theAllParametersList.clear();
	theAllParametersHash.clear();

	// Creating a list of parameters to return at the end
	QList<RParameter *> theParameterList;

	// Getting the list of RResponses that are output of this model
	QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();

	// Looping over QProperties
	for (int i = 0; i < this->metaObject()->propertyCount(); i++) {
		// Getting the meta property
		QMetaProperty metaProperty = this->metaObject()->property(i);

		// Getting the tpe of the meta property
		QVariant::Type type = metaProperty.type();

		// Getting the name of the property
		const char * charName = metaProperty.name();

		// Stage1: Populating the theParameterList with individual parameters, which are represented by QProperties
		// Checking if the type of the property is "QObject *"
		if (type == QMetaType::QObjectStar) {
			// Getting the vaue of the property, which is a "QObject *"
			QObject *propertyObject = this->property(charName).value<QObject *>();

			// Down-casting a pointer with the type "RParameter" to the "QObject *"
			RParameter *parameter = qobject_cast<RParameter *>(propertyObject);

			// If the casting succeeds, it mean that the type of this pointer is RParameter. Proceeding to add it to the list.
			if (parameter) {
				// If the parameter is not already in the list ...
				if (!theAllParametersHash.contains(parameter)) {
					// Down-casting a pointer with the type "RResponse"
					RResponse *response = qobject_cast<RResponse *>(parameter);

					// If the type of this parameter is RResponse, it should be checked hat this RResponse is not an OUTPUT to this model.
					// Thus, if the casting to RResponse succeeds, the "outputResponseList" is searched for this RResponse.
					// If this RResponse was not found in "outputResponseList", OR this parameter is not an RResponse at all ("response" is NULL), then this RParameter pointer is added to the parmeter list.
					if (((response) && (!outputResponseList.contains(response))) || (!response)) {
						theParameterList << parameter;
						theAllParametersHash.insert(parameter, true);
					}
				}
			}

			//// Down-casting a pointer with the type "RLocation" to the "QObject *"
			//RLocation *coordinate = parameterToLocation(propertyObject);

			//// If the casting succeeds, it mean that the type of this pointer is RParameter. Proceeding to add it to the list.
			//if (coordinate) {
			//	QList<RParameter *> coordinateParameterList;
			//	coordinateParameterList << qobject_cast<RParameter *>(coordinate->getLatitude()) << qobject_cast<RParameter *>(coordinate->getLongitude()) << qobject_cast<RParameter *>(coordinate->getAltitude());
			//	
			//	for (int j = 0; j < coordinateParameterList.count(); j++) {
			//		RParameter *parameter = coordinateParameterList[j];
			//		// If the parameter is not already in the list ...
			//		if ((parameter) && (!theParameterList.contains(parameter))) {
			//			theParameterList << parameter;
			//		}
			//	}
			//}

			continue;
		}

		// Stage2: Appending the lists of unlimited number of parameters to the "parameterList".
		// The type of the QProperty representing the unlimited list od parameters is QString.
		// So, if the type of the QProperty is QString, it is considered to be added to theParameterList
		// HOWEVER, it should be noted that there are other QProperties such as "type" and "objectName" that are QString and do not contain any parameter list.
		// So, this naming convention must be kept as a rule:
		// If a QProperty of type QString is to reperesent a parameter list, its name should end with the word "List" (case-sensitive).
		if (type == QMetaType::QString) {
			//QString methodName(charName);
			//methodName.replace(0, 1, methodName.at(0).toUpper());
			//methodName = "get" + methodName;
			////const char * methodCharName = qPrintable(methodName);
			//QByteArray byteArrayName = methodName.toLatin1();
			//const char * methodCharName = byteArrayName.data();
			//RParameterList parameterList;
			//bool ok = QMetaObject::invokeMethod(this, methodCharName, Q_RETURN_ARG(RParameterList, parameterList)); 

			// Check if the property name contains the word "List"
			if (QString(charName).contains("List")) {

				// Producing a list of RParameters form the value of the QProperty, which is a QString
				QList<RPointer<RParameter> > parameterList = stringToParameterList(this->property(charName).toString());

				// Lopping over the produced list
				for (int j = 0; j < parameterList.count(); j++) {
					RParameter *parameter = parameterList[j].data();

					// If the parameter is not already included in "theParameterList", then add it.
					if (!theAllParametersHash.contains(parameter)) {
						theParameterList << parameter;
						theAllParametersHash.insert(parameter, true);
					}
				}
			}
			continue;
		}
	}
	// Now, all the QProperties are looped over.

	// Sorting the generated liest
	theDomain->sort(&theParameterList);

	// Assigning to the data member
	theAllParametersList = theParameterList;

	////Create a list which contains all upstream responses 
	//createUpstreamResponseList();

	*ok = true;
	
	// Returning the generated list
	return theAllParametersList;
}

int RModel::evaluateModelGradient(RObject::RParameterType parameterType)
{
	// IMPELEMENT FINITE DIFFERENCE HERE

	int result = 0;

	theDDMMap.clear();

	// HOW TO GET THE PERTURBATION FACTOR?????????????????????
	double perturbationFactor = 1000;
	//perturbationFactor = property("PerturbationFactor").toDouble();	

	QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();
	// Backing up the response values to return to them after the finite difference analysis
	for (int i = 0; i < outputResponseList.count(); i++) {
		outputResponseList[i]->backup(0);
	}

	// NOTE: IT IS NOT NECESSARY TO DO THE FINITE DIFFERENCE WITH RESPECT TO ALL INPUT PARAMETERS; DIFERENTIATING WITH RESPECT TO  DV/RV/C (DEPNEDING ON THE parameterType) AND RESPONSES IS SUFFICIENT.
	QList<RParameter *> parameterList;
	if (parameterType == RObject::RandomVariable) {
		QList<RRandomVariable *> randomVariableList = getRandomVariableList();
		for (int i = 0; i < randomVariableList.count(); i++) {
			parameterList << randomVariableList[i];
		}
	} else if (parameterType == RObject::DecisionVariable) {
		QList<RDecisionVariable *> decisionVariableList = getDecisionVariableList();
		for (int i = 0; i < decisionVariableList.count(); i++) {
			parameterList << decisionVariableList[i];
		}
	} else if (parameterType == RObject::Constant) {
		QList<RConstant *> constantList = getConstantList();
		for (int i = 0; i < constantList.count(); i++) {
			parameterList << constantList[i];
		}
	}
	QList<RResponse *> inputResponseList = getResponseList();
	for (int i = 0; i < inputResponseList.count(); i++) {
		parameterList << inputResponseList[i];
	}

	int count = parameterList.count();
	
	// Iterating on input parameters to evaluate the partial derivative of the outpur responses with respect to them
	for (int i = 0; i < count; i++) {
		RParameter *parameter = parameterList[i];

		RResponse *inputResponse = qobject_cast<RResponse *>(parameter);
		QVector<double> valueVector;
		int parameterInputCount;
		if (!inputResponse) {
			parameterInputCount = 1;
		} else {
			valueVector = inputResponse->getValueVector(0);
			parameterInputCount = valueVector.count();
			inputResponse->backup(0);
		}

		for (int j = 0; j < parameterInputCount; j++) {
			// Taking a backup from the current value of the parameter
			double currentValueBackup;
			if (!inputResponse) {
				currentValueBackup = parameter->getCurrentValue(0);
			} else {
				currentValueBackup = valueVector[j];
			}
		
			double h;
			if ((parameterType == RObject::RandomVariable) && (!inputResponse)) {
				// Getting the standard deviation of the random variable
				RRandomVariable *randomVariable = qobject_cast<RRandomVariable *>(parameter);
				double standardDeviation = randomVariable->getStandardDeviationValue(0);
				if (standardDeviation == 0) {
					rCritical() << "WARNING: The standard deviation of the random variable" << randomVariable->objectName() << " is 0. Rt is perturbing the random variable by (1.0/perturbation factor) in the finite difference analysis.";
					standardDeviation = 1.0;
				}

				// Perturbing the current value of the random variable 
				h = standardDeviation / perturbationFactor;				
			} else {
				if (currentValueBackup == 0.0) {
					h = 0.001;
					//rCritical() << "WARNING: Parameter is zero, selecting" << h << "as the perturbation in finite difference analysis.";
				} else {
					h = currentValueBackup / perturbationFactor;
				}
			}

			// Perturb the value of the parameter
			double purterbedValue = currentValueBackup + h;
			if (!inputResponse) {					
				parameter->setCurrentValue(purterbedValue, 0);
			} else {
				QVector<double> perturbedVector = valueVector;
				perturbedVector[j] = purterbedValue;
				inputResponse->setValueVector(perturbedVector, 0);
			}

			// Evaluate the model
			int result = evaluateModel(false, parameterType, 0);
			if (result < 0) {
				rCritical() << "Error: Could not evaluate the model" << objectName() << " while calculating its partial derivative with respect to the parameter" << parameter->objectName() << " using finite difference.";
			}

			// Iterate on output responses to calculate the gradient
			for (int k = 0; k < outputResponseList.count(); k++) {
				RResponse *outputResponse = outputResponseList[k];
				QVector<double> backupVector = outputResponse->getBackupVector(0);
				QVector<double> valueVector = outputResponse->getValueVector(0);
				int backupVectorCount = backupVector.count();

				// Establishing the QMap for this response
				if ((i == 0) && (j == 0)) {
					for (int l = 0; l < backupVectorCount; l++) {
						QMap<RParameter *, double> gradientMap;
						theDDMMap.insertMulti(outputResponse, gradientMap);
					}
				}

				// Calculating and assigning the calculated gradient element
				QList<QMap<RParameter *, double> > gradientMapList = theDDMMap.values(outputResponse);
				theDDMMap.remove(outputResponse);
				for (int l = 0; l < backupVectorCount; l++) {
					// Calculating the partial derivative value
					double gradElement = (valueVector[l] - backupVector[l]) / h;

					//rDebug() << "d(" << outputResponse->objectName() << ") / d(" << parameter->objectName() << ") = " << gradElement;

					// Assigning
					gradientMapList[backupVectorCount - 1 - l].insertMulti(parameter, gradElement);
					theDDMMap.insertMulti(outputResponse, gradientMapList[backupVectorCount - 1 - l]);
				}
			}

			// Restoring the current value of the input parameter
			if (!inputResponse) {
				parameter->setCurrentValue(currentValueBackup, 0);	
			} else {
				inputResponse->restore(0);
			}			

			// Restoring the response values to the original values backed up before gradient analysis
			for (int k = 0; k < outputResponseList.count(); k++) {
				outputResponseList[k]->restore(0);
			}
		}
	}
	// Now, all input parameters are looped over.
	
	
	//rCritical() << "Warning: The model" << objectName() << "does not support DDM. Finite difference is performed on this model.";
	
	return 0;
}

void RModel::clearDDMMaps()
{
	theDDMMap.clear();
	theDependenceMap.clear();
}

/*
void RModel::clearNullPointers(QList<RPointer<RParameter> > *passdedParameterList)
{
	for (int i = 0; i < passdedParameterList->count(); i++) {
		if (!passdedParameterList->value(i)) {
			passdedParameterList->removeAt(i);
			i--;
		}
	}
}
*/

QList<RParameter *> RModel::getPhysicalParameterList()
{
	QList<RParameter *> paramList;
	return paramList;
}

void RModel::reset()
{

}

void RModel::updateHistoryVariables(int threadID)
{

}

void RModel::resetHistoryVariables(int threadID)
{

}

int RModel::cubicSmooth(double x0, double epsilon, double y1, double y2, double dy1, double dy2, double *a, double *b, double *c, double *d)
{
	double x1 = x0 - epsilon;
	double x2 = x0 + epsilon;

	gsl_matrix *AA = gsl_matrix_calloc(4, 4);

	gsl_matrix_set(AA, 0, 0, gsl_pow_3(x1));
	gsl_matrix_set(AA, 0, 1, gsl_pow_2(x1));
	gsl_matrix_set(AA, 0, 2, x1);
	gsl_matrix_set(AA, 0, 3, 1.0);

	gsl_matrix_set(AA, 1, 0, gsl_pow_3(x2));
	gsl_matrix_set(AA, 1, 1, gsl_pow_2(x2));
	gsl_matrix_set(AA, 1, 2, x2);
	gsl_matrix_set(AA, 1, 3, 1.0);

	gsl_matrix_set(AA, 2, 0, 3 * gsl_pow_2(x1));
	gsl_matrix_set(AA, 2, 1, 2 * x1);
	gsl_matrix_set(AA, 2, 2, 1.0);
	gsl_matrix_set(AA, 2, 3, 0.0);

	gsl_matrix_set(AA, 3, 0, 3 * gsl_pow_2(x2));
	gsl_matrix_set(AA, 3, 1, 2 * x2);
	gsl_matrix_set(AA, 3, 2, 1.0);
	gsl_matrix_set(AA, 3, 3, 0.0);

	gsl_vector *YY = gsl_vector_calloc(4);

	gsl_vector_set(YY, 0, y1);
	gsl_vector_set(YY, 1, y2);
	gsl_vector_set(YY, 2, dy1);
	gsl_vector_set(YY, 3, dy2);

	gsl_vector *XX = gsl_vector_calloc(4);

	int signum;
	gsl_permutation *permutation = gsl_permutation_alloc(4);
	gsl_linalg_LU_decomp(AA, permutation, &signum);
	gsl_linalg_LU_solve(AA, permutation, YY, XX);

	*a = gsl_vector_get(XX, 0);
	*b = gsl_vector_get(XX, 1);
	*c = gsl_vector_get(XX, 2);
	*d = gsl_vector_get(XX, 3);

	gsl_permutation_free(permutation);
	gsl_vector_free(XX);
	gsl_vector_free(YY);
	gsl_matrix_free(AA);

	return 0;
}

int RModel::cubicSmooth(double x0, double epsilon, double y1, double y2, double dy1, double dy2, double x, double *y)
{	
	double a;
	double b;
	double c;
	double d;
	int result = cubicSmooth(x0, epsilon, y1, y2, dy1, dy2, &a, &b, &c, &d);
	if (result < 0) {
		return result;
	}
	*y = a * gsl_pow_3(x) + b * gsl_pow_2(x) + c * x + d;
	return 0;
}

void RModel::initializeForParallelComputation(int threadID){

	// initialize in superclass
	RObject::initializeForParallelComputation(threadID);

	// call the method on all parameters:
	// start of safe area scope
	{
		QMutexLocker locker(theAllParameterListLock);
		if (theAllParametersList.isEmpty()) {
			bool ok;
			getAllParametersList(&ok);
		}
	}
	// end of safe area scope

	for (int i = 0; i < theAllParametersList.count(); ++i) {
		theAllParametersList[i]->initializeForParallelComputation(threadID);
	}

}

void RModel::createUpstreamResponseList()
{
	QList<RResponse *> responseSearchList = this->getResponseList();

	for (int i = 0; i < responseSearchList.count(); i++) {
		if (i % 100 == 0) {
			QCoreApplication::processEvents();
		}

		RResponse *responseObject = responseSearchList[i];
		// If "theUpstreamResponseList" does not already contain this response ...
		if (!theUpstreamResponseList.contains(responseObject)) {
			// Adding the response to the "theUpstreamResponseList"
			theUpstreamResponseList.append(responseObject);

			// Getting a pointer to the RModel, for which this response is an output.
			RModel *modelObject = qobject_cast<RModel *>(responseObject->getModel());
			QList<RResponse *> tempResponseList;
			tempResponseList = modelObject->getResponseList();

			if (modelObject) {
				for (int j = 0; j < tempResponseList.count(); j++) {
					if (!responseSearchList.contains(tempResponseList[j])) {
						responseSearchList << tempResponseList[j];
					}
				}
			}
		}
		continue;
	}

}

QList<RResponse *> RModel::getUpstreamResponseList()
{
	return theUpstreamResponseList;
}