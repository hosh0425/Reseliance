#include "RObject.h"

#include <QMetaProperty>
#include <QEvent>
#include <QDynamicPropertyChangeEvent>

#include "RParameter.h"
#include "RDomain.h"
#include "RModel.h"
#include "RFunction.h"
#include "RLocation.h"
#include "RLocationResponse.h"
#include "RMainWindow.h"

#include "RParallelComputationManager.h"
#include "ROutputManager.h"
#include <qreadwritelock.h>


#include "RPointer.h" //salarifard

RObject::RObject(QObject *parent, QString name)
	: QObject(parent)
{
	setObjectName(name);
	theAutoGenerated = true;
	theOutputDisplayLevel = RObject::None;
	theOutputDisplayLevelLock = new QReadWriteLock();

	theObjectSharedPointer = QSharedPointer<RObject>(this, &QObject::deleteLater);
}

RObject::~RObject()
{
	delete theOutputDisplayLevelLock;
}

bool RObject::isAutoGenerated()
{
	return theAutoGenerated;
}

void RObject::setAutoGenerated(bool autoGenerated)
{
	theAutoGenerated = autoGenerated;
}

RObject::ROutputDisplayLevelType RObject::getOutputDisplayLevel()
{
	ROutputDisplayLevelType value;

	theOutputDisplayLevelLock->lockForRead();
	value = theOutputDisplayLevel;
	theOutputDisplayLevelLock->unlock();

	return value;
}

void RObject::setOutputDisplayLevel(RObject::ROutputDisplayLevelType value)
{
	theOutputDisplayLevelLock->lockForWrite();
	theOutputDisplayLevel = value;
	theOutputDisplayLevelLock->unlock();
}

void RObject::setObjectName(const QString &name)
{
	QObject *object = qobject_cast<QObject *>(this);
	object->setObjectName(name);
}

int RObject::checkProperties()
{
	// Looping over QProperties
	for (int i = 0; i < this->metaObject()->propertyCount(); i++) {
		// Getting the meta property
		QMetaProperty metaProperty = this->metaObject()->property(i);
		QVariant::Type type = metaProperty.type();
		const char * charName = metaProperty.name();

		// Checking if the type of the property is "QObject *"
		if (type == QMetaType::QObjectStar) {
			// Getting the vaue of the property, which is a "QObject *"
			QObject *propertyObject = this->property(charName).value<QObject *>();
			if (!propertyObject) {
				rCritical() << "Error in object" << objectName() << ": The property" << QString(charName) << "is empty.";
				return -1;
			}
		}
	}
	return 0;
}

double RObject::getDoubleParameter(double *value, RParameter *valueParameter, int threadID)
{
	if (valueParameter) {
		*value = valueParameter->getCurrentValue(threadID);
	}
	return *value;
}

void RObject::setDoubleParameter(double value, double * valueContainer, RParameter *valueParameter , int threadID = 0)
{
	if (valueParameter)
		valueParameter->setCurrentValue(value,threadID);
	
	*valueContainer = value;
}

QString RObject::getStringParameter(double *value, RParameter *valueParameter)
{
	QString result;
	if (valueParameter) {
		*value = valueParameter->getCurrentValue();
		result = valueParameter->objectName();
	} else {
		
		// Is this enough precession?
		result = QString("%1").arg(*value, 0, 'g', 13);
	}
	return result;
}

void RObject::setStringParameter(QString valueStr, double *value, RPointer<RParameter> *valueParameter)
{
	bool ok;
	double temp;
	if (valueStr.isEmpty()) {
		temp = 0.0;
		ok = true;
	} else {
		temp = valueStr.toDouble(&ok);
	}
	if (!ok) {
		RDomain *theDomain = qobject_cast<RDomain *>(parent());
		if (!theDomain) {
			rCritical() << "ATTENTION: The parent of the object" << objectName() << "is not the domain.";
		}
		RParameter *tempParameter = theDomain->findChild<RParameter *>(valueStr);
		if (tempParameter) {
			*valueParameter = tempParameter;
			*value = tempParameter->getCurrentValue();			
		} else {
			if (!valueStr.isEmpty()) {
				rCritical() << "Error: Could not find a parameter named" << valueStr << "in the domain. Reverting back to the previous value.";
			}
		}
	} else {
		valueParameter->clear();
		*value = temp;
	}
}

QString RObject::parameterListToString(QList<RPointer<RParameter> > passedList)
{
	QString string;
	for (int i = 0; i < passedList.count(); i++) {
		if (passedList[i]) {
			string += passedList[i].data()->objectName();
			string += "; ";
		} else {
			passedList.removeAt(i);
			i--;
		}
	}
	return string;
}

QString RObject::modelListToString(QList<RPointer<RModel> > passedList)
{
	QString string;
	for (int i = 0; i < passedList.count(); i++) {
		if (passedList[i]) {
			string += passedList[i].data()->objectName();
			string += "; ";
		} else {
			passedList.removeAt(i);
			i--;
		}
	}
	return string;
}

QString RObject::functionListToString(QList<RPointer<RFunction> > passedList)
{
	QString string;
	for (int i = 0; i < passedList.count(); i++) {
		if (passedList[i]) {
			string += passedList[i].data()->objectName();
			string += "; ";
		} else {
			passedList.removeAt(i);
			i--;
		}
	}
	return string;
}

QList<RPointer<RParameter> > RObject::stringToParameterList(QString passedString)
{
	QList<RPointer<RParameter> > objectList;
	QString string = passedString;

	QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
	QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
	string = "";
	RDomain *theDomain = qobject_cast<RDomain *>(parent());
	for (int i = 0; i < stringList.count(); i++) {
		RParameter *object = theDomain->findChild<RParameter *>(stringList[i]);
		if (object) {
			objectList.append(object);
		} else {
			rCritical() << "Error in" << objectName() << ": Could not find a parameter named" << stringList[i] << "in the domain";
		}
	}
	
	return objectList;
}

QList<RPointer<RModel> > RObject::stringToModelList(QString passedString)
{
	QList<RPointer<RModel> > objectList;
	QString string = passedString;

	QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
	QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
	string = "";
	RDomain *theDomain = qobject_cast<RDomain *>(parent());
	for (int i = 0; i < stringList.count(); i++) {
		RModel *object = theDomain->findChild<RModel *>(stringList[i]);
		if (object) {
			objectList.append(object);
		} else {
			rCritical() << "Error in" << objectName() << ": Could not find a model named" << stringList[i] << "in the domain";
		}
	}
	
	return objectList;
}

QList<RPointer<RFunction> > RObject::stringToFunctionList(QString passedString)
{
	QList<RPointer<RFunction> > objectList;
	QString string = passedString;

	QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
	QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
	string = "";
	RDomain *theDomain = qobject_cast<RDomain *>(parent());
	for (int i = 0; i < stringList.count(); i++) {
		RFunction *object = theDomain->findChild<RFunction *>(stringList[i]);
		if (object) {
			objectList.append(object);
		} else {
			rCritical() << "Error in" << objectName() << ": Could not find a function named" << stringList[i] << "in the domain";
		}
	}
	
	return objectList;
}

QString RObject::intVectorToString(QVector<int> passedVector)
{
	QString result;
	for (int i = 0; i < passedVector.count(); i++) {
		result += QString("%1; ").arg(passedVector[i]);
	}
	return result;
}

QVector<int> RObject::stringToIntVector(QString passedString)
{
	QVector<int> resultVector;
	QString string = passedString;

	QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
	QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
	string = "";
	for (int i = 0; i < stringList.count(); i++) {
		bool ok = false;
		int temp = stringList[i].toInt(&ok);
		if (ok) {
			resultVector.append(temp);
		} else {
			rCritical() << "Error in the Model" << objectName() << ": Could not convert" << stringList[i] << "to an integer.";
		}
	}
	
	return resultVector;
}

QString RObject::doubleVectorToString(QVector<double> passedVector)
{
	QString result;
	for (int i = 0; i < passedVector.count(); i++) {
		result += QString("%1; ").arg(passedVector[i], 0, 'g', 15);
	}
	return result;
}

QVector<double> RObject::stringToDoubleVector(QString passedString)
{
	QVector<double> resultVector;
	QString string = passedString;

	QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
	QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
	string = "";
	for (int i = 0; i < stringList.count(); i++) {
		bool ok = false;
		double temp = stringList[i].toDouble(&ok);
		if (ok) {
			resultVector.append(temp);
		} else {
			rCritical() << "Error in the Model" << objectName() << ": Could not convert" << stringList[i] << "to a double precision real number.";
		}
	}
	
	return resultVector;
}

RLocation * RObject::parameterToLocation(RParameter *parameter)
{
	RLocation *location = qobject_cast<RLocation *>(parameter);
	if (location) {
		return location;
	}
	RLocationResponse *locationResponse = qobject_cast<RLocationResponse *>(parameter);
	if (locationResponse) {
		location = qobject_cast<RLocation *>(locationResponse->getLocation());
		if (location) {
			return location;
		} else {
			rCritical() << "Warning: The location response" << locationResponse->objectName() << "does not include any location object.";
			return 0;
		}
	}
	if (parameter) {
		rCritical() << "Warning: The parameter" << parameter->objectName() << "is not a location or location response object.";
	}
	return 0;
}

QList<RLocation *> RObject::parameterListToLocationList(QList<RPointer<RParameter> > parameterList, bool checkForDuplicates)
{
	QList<RLocation *> locationList;
	for (int i = 0; i < parameterList.count(); i++) {
		if (parameterList[i]) {
			RLocation *location = parameterToLocation(parameterList[i].data());
			if (location) {
				locationList << location;
			}
		}
	}

	if (checkForDuplicates) {
		for (int i = 0; i < locationList.count(); i++) {
			for (int j = i + 1; j < locationList.count(); j++) {
				if (locationList[i]->getLatitude() == locationList[j]->getLatitude() && locationList[i]->getLongitude() == locationList[j]->getLongitude()) {
					if (!RMainWindow::noWarning) {
						rCritical() << "Warning: The locations" << locationList[i]->objectName() << "and" << locationList[j]->objectName() << "entered in object" << objectName() << "have identical coordinates. This can result in unpredictable errors.";
					}
				}
			}
		}
	}

	return locationList;
}

bool RObject::event(QEvent *e)
{
	if (e->type() == QEvent::DynamicPropertyChange) {
		QDynamicPropertyChangeEvent *changeEvent = static_cast<QDynamicPropertyChangeEvent *>(e);
		const char *propertyNameChar = changeEvent->propertyName().constData();
		QString propertyName = QString(propertyNameChar);
		QVariant propertyValue = this->property(propertyNameChar);
		if (propertyValue != QVariant()) {
			setDynamicProperty(propertyName, propertyValue);
		}
		return true;
	} else {
		return QObject::event(e);
	}
}

void RObject::setDynamicProperty(QString propertyName, QVariant propertyValue)
{
	return;
}

QStringList RObject::getActionList()
{
	return QStringList();
}

int RObject::getArraySizeForParallelizedObject(){

	return (RParallelComputationManager::getInstance()->getMaxThreadCount() + 1);
}

void RObject::initializeForParallelComputation(int threadID){

	// ATTENTION : as the function has access to all contributed objects (explicitly or implicitly) there is no need to loop over QObject* properties here
}

void RObject::resetAfterParallelComputation(){

	// ATTENTION : as the function has access to all contributed objects (explicitly or implicitly) there is no need to loop over QObject* properties here
}

bool RObject::canBeRunParallelly(){
	return false;
}

bool RObject::canAllQObjectStarPropertiesBeRunParallelly(){

	// checking all QProperties of type QObject *
	for (int i = 0; i < this->metaObject()->propertyCount(); i++) {
			
		// Getting the meta property
		QMetaProperty metaProperty = this->metaObject()->property(i);

		// Getting the tpe of the meta property
		QVariant::Type type = metaProperty.type();

		// Getting the name of the property
		const char * charName = metaProperty.name();

		// Checking if the type of the property is "QObject *"
		if (type == QMetaType::QObjectStar) {
			// Getting the vaue of the property, which is a "QObject *"
			RObject  *propertyObject = qobject_cast<RObject *> (this->property(charName).value<QObject *>());

			if (propertyObject){
				if (!propertyObject->canBeRunParallelly()){
					rDebug() << "The "<< propertyObject->objectName()<<" does not include the necessary implementations. ";
					return false;
				}
			}
		}
	}

	return true;
}

QDebug RObject::rDebug(int threadID){

	return ROutputManager::getInstance()->getDebugStreamInput(threadID);
}

QDebug RObject::rCritical(int threadID){

	return ROutputManager::getInstance()->getCriticalStreamInput(threadID);
}

QSharedPointer<RObject> RObject::getObjectSharedPointer() {
	return theObjectSharedPointer;
}

void RObject::dereferenceSharedPointerToDeleteObject() {
	theObjectSharedPointer.reset();
}
